/*
  ==============================================================================

    This file was auto-generated by the Jucer!

    It contains the basic startup code for a Juce application.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include <cmath>


//==============================================================================
JuceDemoPluginAudioProcessorEditor::JuceDemoPluginAudioProcessorEditor (JuceDemoPluginAudioProcessor* ownerFilter)
    : AudioProcessorEditor (ownerFilter),
      nameLabel("", "Chih-Wei & Xinquan"),
      infoLabel (String::empty),
      bypassLabel("", "bypass button"),
      modFreqLabel ("", "Modulation Frequency (sec):"),
      modAmpLabel ("", "Modulation Amplitude (sec):"),
      modFreqSlider ("modulation frequency (sec)"),
      modAmpSlider ("modulation amplitude (sec)"),
      meterLeftChannel(nullptr),
      meterRightChannel(nullptr)
{
    myMeterValue = new float [2];
    
    // add some sliders..
    addAndMakeVisible (modFreqSlider);
    modFreqSlider.addListener (this);
    modFreqSlider.setRange (0.0, 20.0, 0.01); //freq in Hz

    addAndMakeVisible (modAmpSlider);
    modAmpSlider.addListener (this);
    modAmpSlider.setRange (0.0, ownerFilter->fMaxDelayInS, 0.01);    //amp in sec

    // add some buttons..
    bypassButton = new TextButton ("bypass button");
    addAndMakeVisible(bypassButton);
    bypassButton->addListener(this);
    
    // add some labels for the sliders..
    modFreqLabel.attachToComponent (&modFreqSlider, false);
    modFreqLabel.setFont (Font (11.0f));

    modAmpLabel.attachToComponent (&modAmpSlider, false);
    modAmpLabel.setFont (Font (11.0f));
    
    addAndMakeVisible(nameLabel);
    nameLabel.setFont(Font (20.0f));

    // add a label that will display the current timecode and status..
    addAndMakeVisible (infoLabel);
    infoLabel.setColour (Label::textColourId, Colours::blue);
    infoLabel.setFont(Font (20.0f));
    
    
    // add meter component
    meterLeftChannel = new MeterComponent ();
    addAndMakeVisible(meterLeftChannel);
    meterRightChannel = new MeterComponent ();
    addAndMakeVisible(meterRightChannel);


    setSize (600, 400);

    startTimer (10); //update every 10 ms
}

JuceDemoPluginAudioProcessorEditor::~JuceDemoPluginAudioProcessorEditor()
{
    delete [] myMeterValue;
}

//==============================================================================
void JuceDemoPluginAudioProcessorEditor::paint (Graphics& g)
{
    g.setColour(Colours::grey);
    g.fillAll();
    
}

void JuceDemoPluginAudioProcessorEditor::resized()
{
    nameLabel.setBounds (100, 100, 150, 40);
    infoLabel.setBounds (10, 4, 400, 25);
    modFreqSlider.setBounds (20, 60, 150, 40);
    modAmpSlider.setBounds (200, 60, 150, 40);
    bypassButton->setBounds (100, 150, 150, 40);
    meterLeftChannel->setBounds(300, 150, 200, 30);
    meterRightChannel->setBounds(300, 190, 200, 30);

    
}

//==============================================================================
// This timer periodically checks whether any of the filter's parameters have changed...
void JuceDemoPluginAudioProcessorEditor::timerCallback()
{
    JuceDemoPluginAudioProcessor *ourProcessor = getProcessor();

//    AudioPlayHead::CurrentPositionInfo newPos (ourProcessor->lastPosInfo);

//    if (lastDisplayedPosition != newPos)
//        displayPositionInfo (newPos);

    modFreqSlider.setValue (ourProcessor->modFreq, dontSendNotification);
    modAmpSlider.setValue (ourProcessor->modAmp, dontSendNotification);
    
    ourProcessor->getPPMValue(myMeterValue);
    meterLeftChannel->setValue(myMeterValue[0]);
    meterRightChannel->setValue(myMeterValue[1]);
    meterLeftChannel->repaint();
    meterRightChannel->repaint();
    
}

// This is our Slider::Listener callback, when the user drags a slider.
void JuceDemoPluginAudioProcessorEditor::sliderValueChanged (Slider* slider)
{
    if (slider == &modFreqSlider)
    {
        // It's vital to use setParameterNotifyingHost to change any parameters that are automatable
        // by the host, rather than just modifying them directly, otherwise the host won't know
        // that they've changed.
        getProcessor()->setParameterNotifyingHost (JuceDemoPluginAudioProcessor::modFreqParam,
                                                   (float) modFreqSlider.getValue());
    }
    else if (slider == &modAmpSlider)
    {
        getProcessor()->setParameterNotifyingHost (JuceDemoPluginAudioProcessor::modAmpParam,
                                                   (float) modAmpSlider.getValue());
    }
}

void JuceDemoPluginAudioProcessorEditor::buttonClicked (Button* button)
{
    if (button == bypassButton)
    {
        JuceDemoPluginAudioProcessor *ourProcessor = getProcessor();
        float curStatus = ourProcessor->bypassStatus;
        
        if (curStatus == 1.0f)
        {
            ourProcessor->setParameterNotifyingHost(JuceDemoPluginAudioProcessor::bypassParam, 0.0f);
        }
        else
        {
            ourProcessor->setParameterNotifyingHost(JuceDemoPluginAudioProcessor::bypassParam, 1.0f);
        }
    }
    
}



////==============================================================================
//// quick-and-dirty function to format a timecode string
//static const String timeToTimecodeString (const double seconds)
//{
//    const double absSecs = fabs (seconds);
//
//    const int hours =  (int) (absSecs / (60.0 * 60.0));
//    const int mins  = ((int) (absSecs / 60.0)) % 60;
//    const int secs  = ((int) absSecs) % 60;
//
//    String s (seconds < 0 ? "-" : "");
//
//    s << String (hours).paddedLeft ('0', 2) << ":"
//      << String (mins) .paddedLeft ('0', 2) << ":"
//      << String (secs) .paddedLeft ('0', 2) << ":"
//      << String (roundToInt (absSecs * 1000) % 1000).paddedLeft ('0', 3);
//
//    return s;
//}
//
//// quick-and-dirty function to format a bars/beats string
//static const String ppqToBarsBeatsString (double ppq, double /*lastBarPPQ*/, int numerator, int denominator)
//{
//    if (numerator == 0 || denominator == 0)
//        return "1|1|0";
//
//    const int ppqPerBar = (numerator * 4 / denominator);
//    const double beats  = (fmod (ppq, ppqPerBar) / ppqPerBar) * numerator;
//
//    const int bar    = ((int) ppq) / ppqPerBar + 1;
//    const int beat   = ((int) beats) + 1;
//    const int ticks  = ((int) (fmod (beats, 1.0) * 960.0 + 0.5));
//
//    String s;
//    s << bar << '|' << beat << '|' << ticks;
//    return s;
//}

//// Updates the text in our position label.
//void JuceDemoPluginAudioProcessorEditor::displayPositionInfo (const AudioPlayHead::CurrentPositionInfo& pos)
//{
//    lastDisplayedPosition = pos;
//    String displayText;
//    displayText.preallocateBytes (128);
//
//    displayText << String (pos.bpm, 2) << " bpm, "
//                << pos.timeSigNumerator << '/' << pos.timeSigDenominator
//                << "  -  " << timeToTimecodeString (pos.timeInSeconds)
//                << "  -  " << ppqToBarsBeatsString (pos.ppqPosition, pos.ppqPositionOfLastBarStart,
//                                                    pos.timeSigNumerator, pos.timeSigDenominator);
//
//    if (pos.isRecording)
//        displayText << "  (recording)";
//    else if (pos.isPlaying)
//        displayText << "  (playing)";
//
//    infoLabel.setText (displayText, dontSendNotification);
//}


//================ meter component ================

MeterComponent::MeterComponent() : m_fInternalValue(0)
{
    setSize(200, 30);
}

MeterComponent::~MeterComponent()
{
}

void MeterComponent::paint(Graphics &g)
{
    // background
    g.setColour(Colours::black);
    g.fillRect(0, 0, 200, 30);
    // moving green
    float currentValue = getValue();
    int greenLen = floor(currentValue * 190);
    g.setColour(Colours::green);
    g.fillRect(5, 5, greenLen, 20);
    
}

void MeterComponent::setValue (float fMeterValue)
{
    // value needs to be transformed to dB
    float meterValueInDb = 20 * log10f(fMeterValue);
    float displayValue = 0;
    if (meterValueInDb > -12)
    {
        displayValue = (meterValueInDb + 12) / 12; //between 0~1
        
    }
    m_fInternalValue = displayValue;
}

float MeterComponent::getValue()
{
    return m_fInternalValue;
}








